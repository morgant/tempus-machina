#!/bin/sh -e

#
# tmutil - a macOS (nee OS X) work-alike powered by rsync
#

# info
tool="$(basename "$0")"
version="0.1"
copyright="(c) 2021 Morgan Aldridge"

# global variables
verbose=false
host="$(hostname)"
config_path="/etc/${tool}"
verb=""

# print usage instructions (help)
usage() {
  echo "Usage: ${tool} <verb> [options]"
  echo
}

version() {
  echo "${tool} v${version} ${copyright}"
}

is_root() {
  if [ $(id -u) -ne 0 ] ; then
    return 1
  fi
}

init_path_uuid() {
  if [ -z "$1" -o ! -d "$1" ] ; then
    return 1
  fi
  if [ -f "${1}/.uuid" ] ; then
    $verbose && echo "UUID for path '$1' already exists."
  else
    if uuidgen > "${1}/.uuid" ; then
      $verbose && echo "Generated new UUID for path '$1'."
    else
      echo "Error generating UUID for path '$1'!"
      return 1
    fi
  fi
}

path_uuid() {
  if [ ! -d "${1}" -o ! -f "${1}/.uuid" ] ; then
    return 1
  fi
  cat "${1}/.uuid"
}

init_configs() {
  if [ ! -d "${config_path}" ] ; then
    if mkdir -p "${config_path}" ; then
      $verbose && echo "Created config path '${config_path}'"

      init_path_uuid "${config_path}"

      touch "${config_path}/destinations"
      $verbose && echo "Created '${config_path}/destinations' config file"

      touch "${config_path}/exclusions"
      $verbose && echo "Created '${config_path}/exclusions' config file"
    else
      echo "Error! Unable to create config path '${config_path}'!"
      return 1
    fi
  else
    $verbose && echo "Config path '${config_path}' exists"
  fi
}

root_uuid() {
  path_uuid "${config_path}"
}

is_valid_destination() {
  if [ -z "$1" -o ! -d "$1" ] ; then
    return 1
  fi
}

init_destination() {
  if ! is_valid_destination "$1" ; then
    return 1
  fi

  if [ ! -d "${1}/Backups.backupdb" ] ; then
    mkdir -p "${1}/Backups.backupdb"
    $verbose && echo "Created 'Backups.backupdb' in destination '$1'."
  else
    $verbose && echo "Destination '$1' already has a 'Backups.backupdb'."
  fi

  init_path_uuid "${1}/Backups.backupdb"

  if [ ! -d "${1}/Backups.backupdb/${host}" ] ; then
    mkdir -p "${1}/Backups.backupdb/${host}"
    $verbose && echo "Created machine directory in destination '$1'."
  else
    $verbose && echo "Destination '$1' already has a machine directory."
  fi
}

is_destination_remote() {
  echo "$1" | grep -E ".+:./+" > /dev/null
}

destination_type() {
  is_destination_remote "$1" && echo "Remote" || echo "Local"
}

destination_uuid() {
  path_uuid "${1}/Backups.backupdb"
}

has_destination_mount() {
  while IFS= read -r line ; do
    if [ "$line" = "$(destination_uuid "$1")=$1" ] ; then
      return 0
    fi
  done < "${config_path}/destinations"
  return 1
}

has_destination_uuid() {
  while IFS= read -r line ; do
    if [ "$(destination_config_uuid "$line")" = "$1" ] ; then
      return 0
    fi
  done < "${config_path}/destinations"
  return 1
}

destination_config_mount() {
  #echo "${1#$(destination_config_uuid "$1")=}"
  echo "${1#*=}"
}

destination_config_uuid() {
  #echo "$1" | grep -Eo "^[^=]+"
  echo "${1%%=*}"
}

destination_mount_by_uuid() {
  while IFS= read -r line ; do
    if [ "$(destination_config_uuid "$line")" = "$1" ] ; then
      echo "$(destination_config_mount "$line")"
      return 0
    fi
  done < "${config_path}/destinations"
  return 1
}

print_destinations() {
  while IFS= read -r line ; do
    echo "===================================================="
    echo "Name          : n/a"
    echo -n "Kind          : "
    destination_type "$(destination_config_mount "${line}")"
    echo -n "Mount Point   : "
    destination_config_mount "${line}"
    echo -n "ID            : "
    destination_config_uuid "${line}"
  done < "${config_path}/destinations"
}

remove_all_destinations() {
  echo -n "" > "${config_path}/destinations"
  $verbose && echo "Removed all destinations"
}

remove_destination() {
  if [ -z "$1" ] ; then
    echo "Error! Must provide a destination ID to remove!"
    return 1
  fi

  config_tmp="$(mktemp -d)"
  if [ ! -d "${config_tmp}" ] ; then
    echo "Error! Unable to create tmp directory!"
    return 1
  fi
  touch "${config_tmp}/destinations"

  while IFS= read -r line ; do
    if [ "$line" != "${1}=$(destination_config_mount "${line}")" ] ; then
      echo "${line}" >> "${config_tmp}/destinations"
    fi
  done < "${config_path}/destinations"

  if diff -q "${config_tmp}/destinations" "${config_path}/destinations" > /dev/null ; then
    echo "Error! Could not find destination with ID '${1}' to remove!"
    rm -r "${config_tmp}"
    return 1
  else
    echo "Removed destination with ID '${1}'."
    mv "${config_tmp}/destinations" "${config_path}/destinations"
    rm -r "${config_tmp}"
  fi
}

add_destination() {
  if ! is_valid_destination "$1" ; then
    echo "Error! Could not add '${1}' because it not a valid destination!"
    return 1
  fi

  if has_destination_mount "$1" ; then
    $verbose && echo "Destination '${1}' already added"
  else
    init_destination "$1"

    echo "$(destination_uuid "$1")=$1" >> "${config_path}/destinations"
    $verbose && echo "Added destination '${1}'"
  fi
}

machine_directory() {
  while IFS= read -r line ; do
    echo "$(destination_config_mount "${line}")/Backups.backupdb/${host}"
  done < "${config_path}/destinations"
}

machine_backups() {
  while IFS= read -r line ; do
    find "$(destination_config_mount "${line}")/Backups.backupdb/${host}" -type d -mindepth 1 -maxdepth 1 ! -name "Latest"
  done < "${config_path}/destinations"
}

has_destination_mount_previous_backup() {
  [ -z "$1" ] && return 1
  if is_destination_remote "$1" ; then
    echo "ERROR! Could not determine if remote destination '${1}' has previous backup because remote destinations are not yet supported!"
    return 1
  elif [ ! -d "$1" -o ! -h "${1}/Backups.backupdb/${host}/Latest" ] ; then
    return 1
  fi
}

destination_mount_previous_backup() {
  [ -z "$1" ] && return 1
  if is_destination_remote "$1" ; then
    echo "ERROR! Could not find remote destination '${1}' previous backup because remote destinations are not yet supported!"
    return 1
  else
    [ ! -d "$1" ] && return 1
    readlink "${1}/Backups.backupdb/${host}/Latest"
  fi
}

destination_mount_finalize_backup() {
  [ -z "$1" -o -z "$2" -o -z "$3" ] && return 1
  if is_destination_remote "$1" ; then
    echo "ERROR! Could not finalize remote destination '${1}' backup '${2}' because remote destinations are not yet supported!"
    return 1
  else
    [ ! -d "${1}" ] && return 1

    # move the backup to its final name
    mv "${1}/Backups.backupdb/${host}/${2}" "${1}/Backups.backupdb/${host}/${3}"

    # symlink as latest
    [ -h "${1}/Backups.backupdb/${host}/Latest" ] && rm "${1}/Backups.backupdb/${host}/Latest"
    ln -s "${1}/Backups.backupdb/${host}/${3}" "${1}/Backups.backupdb/${host}/Latest"
  fi
}

has_exclusion() {
  while IFS= read -r line ; do
    if [ "$line" = "$1" ] ; then
      return 0
    fi
  done < "${config_path}/exclusions"
  return 1
}

add_exclusion() {
  if [ -z "$1" ] ; then
    echo "Error! Must provide an exclusion!"
    return 1
  fi

  while [ $# -gt 0 ] ; do
    if has_exclusion "$1" ; then
      echo "Exclusion '${1}' already exists."
    else
      [ ! -e "$1" ] && echo "WARNING: exclusion target file or directory '${1}' does not yet exist!"
      echo "$1" >> "${config_path}/exclusions" && echo "Added exclusion '${1}'."
    fi
    shift
  done
}

remove_exclusion() {
  if [ -z "$1" ] ; then
    echo "Error! Must provide an exclusion!"
    return 1
  fi

  config_tmp="$(mktemp -d)"
  if [ ! -d "${config_tmp}" ] ; then
    echo "Error! Unable to create tmp directory!"
    return 1
  fi

  while [ $# -gt 0 ] ; do
    touch "${config_tmp}/exclusions"

    while IFS= read -r line ; do
      [ "$line" != "$1" ] && echo "${line}" >> "${config_tmp}/exclusions"
    done < "${config_path}/exclusions"

    if diff -q "${config_tmp}/exclusions" "${config_path}/exclusions" > /dev/null ; then
      echo "WARNING! Could not find exclusion '${1}' to remove!"
      rm "${config_tmp}/exclusions"
    else
      echo "Removed exclusion '${1}'."
      mv "${config_tmp}/exclusions" "${config_path}/exclusions"
    fi
    shift
  done
  rm -r "${config_tmp}"
}

is_excluded() {
  while [ $# -gt 0 ] ; do
    [ -z "$1" ] && continue

    excluded=false
    while IFS= read -r line ; do
      if echo "$1" | grep -q "${line}" ; then
        excluded=true
        break
      fi
    done < "${config_path}/exclusions"

    $excluded && echo "[Excluded] ${1}" || echo "[Included] ${1}"
    shift
  done
}

backup() {
  if [ -n "$1" ] ; then
    if ! has_destination_uuid "$1" ; then
      echo "Error! No destination found with ID '$1'!"
      exit 1
    fi
  fi

  while IFS= read -r line ; do
    rsync_dest_mount=""
    rsync_dest=""
    rsync_dest_final="$(date "+%Y-%m-%d-%H%M%S")"
    rsync_dest_tmp=".${rsync_dest_final}"
    rsync_dest_prev=""
    rsync_sucess=false

    if [ -n "$1" ] ; then
      if [ "${line}" = "${1}=$(destination_mount_by_uuid "${1}")" ] ; then
        rsync_dest_mount="$(destination_mount_by_uuid "$1")"
      else
        continue
      fi
    else
      rsync_dest_mount="$(destination_config_mount "${line}")"
    fi
    rsync_dest="${rsync_dest_mount}/Backups.backupdb/${host}/${rsync_dest_tmp}/"

    if is_destination_remote "${rsync_dest_mount}" ; then
      echo "ERROR! Could not backup to remote destination '${rsync_dest_mount}' because remote destinations are not yet supported!"
      return 1
    fi

    if ! has_destination_mount_previous_backup "${rsync_dest_mount}" ; then
      $verbose && echo "Starting full backup to '${rsync_dest}'..."
      rsync \
        --recursive \
        --perms \
        --owner \
        --group \
        --times \
        --links \
        --delete \
        --delete-excluded \
        --exclude-from="${config_path}/exclusions" \
        "/" \
        "${rsync_dest}" && rsync_success=true
    else
      $verbose && echo "Starting incremental backup to '${rsync_dest}'..."
      rsync_dest_prev="$(destination_mount_previous_backup "${rsync_dest_mount}")"
      rsync \
        --recursive \
        --perms \
        --owner \
        --group \
        --times \
        --links \
        --delete \
        --delete-excluded \
        --exclude-from="${config_path}/exclusions" \
        --link-dest="${rsync_dest_prev}" \
        "/" \
        "${rsync_dest}" && rsync_success=true
    fi
    if $rsync_success ; then
      $verbose && echo "Successfully completed backup to '${rsync_dest}'."
      destination_mount_finalize_backup "${rsync_dest_mount}" "${rsync_dest_tmp}" "${rsync_dest_final}"
    else
      echo "ERROR! Unknown errors occurred during backup to  '${rsync_dest}'!"
    fi
  done < "${config_path}/destinations"
}

main() {
  # parse input args
  if [ $# -eq 0 ]; then
    usage
    exit 1
  fi
  while [ $# -gt 0 -a -z "${verb}" ]; do
    case "$1" in
      -h|--help|help)
        usage
        exit
        ;;
      -v)
        verbose=true
        ;;
      -V|--version|version)
        version
        exit
        ;;
      setdestination|destinationinfo|removedestination|machinedirectory|listbackups|addexclusion|removeexclusion|isexcluded|startbackup)
        verb="$1"
        ;;
      *)
        echo "Unknown verb '${1}'."
        usage
        exit 1
        ;;
    esac
    shift
  done

  if [ -z "${verb}" ] ; then
    usage
    exit 1
  fi

  init_configs

  case "${verb}" in
    setdestination)
      ! is_root && echo "ERROR! The '${verb}' verb requires root privileges!" && exit 1
      setdestination_append=false
      while getopts a opt_name ; do
        case "${opt_name}" in
          a)
            setdestination_append=true
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND - 1 ))
      if ! $setdestination_append && is_valid_destination "$1" ; then
        remove_all_destinations
      fi
      add_destination "$1"
      ;;
    destinationinfo)
      while getopts X opt_name ; do
        case "${opt_name}" in
          X)
            echo "The '-${opt_name}' option for '${verb}' verb is not supported at this time."
            usage
            exit 1
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND - 1 ))
      print_destinations
      ;;
    removedestination)
      ! is_root && echo "ERROR! The '${verb}' verb requires root privileges!" && exit 1
      remove_destination "$1"
      ;;
    machinedirectory)
      machine_directory
      ;;
    listbackups)
      machine_backups
      ;;
    addexclusion)
      ! is_root && echo "ERROR! The '${verb}' verb requires root privileges!" && exit 1
      addexclusion_fixed=false
      while getopts p opt_name ; do
        case "$opt_name" in
          p)
            addexclusion_fixed=true
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND -1 ))

      if ! $addexclusion_fixed ; then
        echo "Error! The '-p' option is required for the '${verb}' verb."
        exit 1
      fi
      add_exclusion "$@"
      ;;
    removeexclusion)
      ! is_root && echo "ERROR! The '${verb}' verb requires root privileges!" && exit 1
      removeexclusion_fixed=false
      while getopts p opt_name ; do
        case "$opt_name" in
          p)
            removeexclusion_fixed=true
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND -1 ))

      if ! $removeexclusion_fixed ; then
        echo "Error! The '-p' option is required for the '${verb}' verb."
        exit 1
      fi
      remove_exclusion "$@"
      ;;
    isexcluded)
      while getopts X opt_name ; do
        case "${opt_name}" in
          X)
            echo "The '-${opt_name}' option for '${verb}' verb is not supported at this time."
            usage
            exit 1
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND - 1 ))
      is_excluded "$@"
      ;;
    startbackup)
      ! is_root && echo "ERROR! The '${verb}' verb requires root privileges!" && exit 1
      startbackup_block=false
      startbackup_rotation=false
      startbackup_dest_uuid=""
      while getopts "brd:" opt_name ; do
        case "${opt_name}" in
          b)
            startbackup_block=true
            ;;
          r)
            startbackup_rotation=true
            echo "The '-${opt_name}' option for '${verb}' verb is not supported at this time."
            ;;
          d)
            startbackup_dest_uuid="$OPTARG"
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND - 1 ))

      if ! $startbackup_block; then
        echo "Error! The '-b' option is required for the '${verb}' verb."
        exit 1
      fi
      backup "${startbackup_dest_uuid}"
      ;;
  esac
}

main "$@"
