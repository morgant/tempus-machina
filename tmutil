#!/bin/sh -e

#
# tmutil - a macOS (nee OS X) work-alike powered by rsync
#

# info
tool="$(basename "$0")"
version="0.1"
copyright="(c) 2021 Morgan Aldridge"

# global variables
verbose=false
host="$(hostname)"
config_path="/etc/${tool}"
config_path=".${config_path}" # TODO: remove this development hack
verb=""

# print usage instructions (help)
usage() {
  echo "Usage: ${tool} <verb> [options]"
  echo
}

version() {
  echo "${tool} v${version} ${copyright}"
}

init_path_uuid() {
  if [ -z "$1" -o ! -d "$1" ] ; then
    return 1
  fi
  if [ -f "${1}/.uuid" ] ; then
    $verbose && echo "UUID for path '$1' already exists."
  else
    if uuidgen > "${1}/.uuid" ; then
      $verbose && echo "Generated new UUID for path '$1'."
    else
      echo "Error generating UUID for path '$1'!"
      return 1
    fi
  fi
}

path_uuid() {
  if [ ! -d "${1}" -o ! -f "${1}/.uuid" ] ; then
    return 1
  fi
  cat "${1}/.uuid"
}

init_configs() {
  if [ ! -d "${config_path}" ] ; then
    if mkdir -p "${config_path}" ; then
      $verbose && echo "Created config path '${config_path}'"

      init_path_uuid "${config_path}"

      touch "${config_path}/destinations"
      $verbose && echo "Created '${config_path}/destinations' config file"

      touch "${config_path}/exclusions"
      $verbose && echo "Created '${config_path}/exclusions' config file"
    else
      echo "Error! Unable to create config path '${config_path}'!"
      return 1
    fi
  else
    $verbose && echo "Config path '${config_path}' exists"
  fi
}

root_uuid() {
  path_uuid "${config_path}"
}

is_valid_destination() {
  if [ -z "$1" -o ! -d "$1" ] ; then
    return 1
  fi
}

init_destination() {
  if ! is_valid_destination "$1" ; then
    return 1
  fi

  if [ ! -d "${1}/Backups.backupdb" ] ; then
    mkdir -p "${1}/Backups.backupdb"
    $verbose && echo "Created 'Backups.backupdb' in destination '$1'."
  else
    $verbose && echo "Destination '$1' already has a 'Backups.backupdb'."
  fi

  init_path_uuid "${1}/Backups.backupdb"

  if [ ! -d "${1}/Backups.backupdb/${host}" ] ; then
    mkdir -p "${1}/Backups.backupdb/${host}"
    $verbose && echo "Created machine directory in destination '$1'."
  else
    $verbose && echo "Destination '$1' already has a machine directory."
  fi
}

is_remote_destination() {
  echo "$1" | grep -E ".+:./+" > /dev/null
}

destination_type() {
  is_remote_destination "$1" && echo "Remote" || echo "Local"
}

destination_uuid() {
  path_uuid "${1}/Backups.backupdb"
}

has_destination() {
  while IFS= read -r line ; do
    if [ "$line" = "$(destination_uuid "$1")=$1" ] ; then
      return 0
    fi
  done < "${config_path}/destinations"
  return 1
}

destination_config_mount() {
  #echo "${1#$(destination_config_uuid "$1")=}"
  echo "${1#*=}"
}

destination_config_uuid() {
  #echo "$1" | grep -Eo "^[^=]+"
  echo "${1%%=*}"
}

print_destinations() {
  while IFS= read -r line ; do
    echo "===================================================="
    echo "Name          : n/a"
    echo -n "Kind          : "
    destination_type "$(destination_config_mount "${line}")"
    echo -n "Mount Point   : "
    destination_config_mount "${line}"
    echo -n "ID            : "
    destination_config_uuid "${line}"
  done < "${config_path}/destinations"
}

remove_all_destinations() {
  echo -n "" > "${config_path}/destinations"
  $verbose && echo "Removed all destinations"
}

remove_destination() {
  if [ -z "$1" ] ; then
    echo "Error! Must provide a destination ID to remove!"
    return 1
  fi

  config_tmp="$(mktemp -d)"
  if [ ! -d "${config_tmp}" ] ; then
    echo "Error! Unable to create tmp directory!"
    return 1
  fi
  touch "${config_tmp}/destinations"

  while IFS= read -r line ; do
    if [ "$line" != "${1}=$(destination_config_mount "${line}")" ] ; then
      echo "${line}" >> "${config_tmp}/destinations"
    fi
  done < "${config_path}/destinations"

  if diff -q "${config_tmp}/destinations" "${config_path}/destinations" > /dev/null ; then
    echo "Error! Could not find destination with ID '${1}' to remove!"
    rm -r "${config_tmp}"
    return 1
  else
    echo "Removed destination with ID '${1}'."
    mv "${config_tmp}/destinations" "${config_path}/destinations"
    rm -r "${config_tmp}"
  fi
}

add_destination() {
  if ! is_valid_destination "$1" ; then
    echo "Error! Could not add '${1}' because it not a valid destination!"
    return 1
  fi

  if has_destination "$1" ; then
    $verbose && echo "Destination '${1}' already added"
  else
    init_destination "$1"

    echo "$(destination_uuid "$1")=$1" >> "${config_path}/destinations"
    $verbose && echo "Added destination '${1}'"
  fi
}

machine_directory() {
  while IFS= read -r line ; do
    echo "$(destination_config_mount "${line}")/Backups.backupdb/${host}"
  done < "${config_path}/destinations"
}

machine_backups() {
  while IFS= read -r line ; do
    find "$(destination_config_mount "${line}")/Backups.backupdb/${host}" -type d -mindepth 1 -maxdepth 1 ! -name "Latest"
  done < "${config_path}/destinations"
}

has_exclusion() {
  while IFS= read -r line ; do
    if [ "$line" = "$1" ] ; then
      return 0
    fi
  done < "${config_path}/exclusions"
  return 1
}

add_exclusion() {
  if [ -z "$1" ] ; then
    echo "Error! Must provide an exclusion!"
    return 1
  fi

  if has_exclusion "$1" ; then
    echo "Exclusion '${1}' already exists."
    return 0
  fi

  if [ ! -e "$1" ]; then
    echo "WARNING: exclusion target file or directory '${1}' does not yet exist!"
  fi
  echo "$1" >> "${config_path}/exclusions" && echo "Added exclusion '${1}'."
}

main() {
  # parse input args
  if [ $# -eq 0 ]; then
    usage
    exit 1
  fi
  while [ $# -gt 0 -a -z "${verb}" ]; do
    case "$1" in
      -h|--help|help)
        usage
        exit
        ;;
      -v)
        verbose=true
        ;;
      -V|--version|version)
        version
        exit
        ;;
      setdestination|destinationinfo|removedestination|machinedirectory|listbackups|addexclusion)
        verb="$1"
        ;;
      *)
        echo "Unknown verb '${1}'."
        usage
        exit 1
        ;;
    esac
    shift
  done

  if [ -z "${verb}" ] ; then
    usage
    exit 1
  fi

  init_configs

  case "${verb}" in
    setdestination)
      setdestination_append=false
      while getopts a opt_name ; do
        case "${opt_name}" in
          a)
            setdestination_append=true
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND - 1 ))
      if ! $setdestination_append && is_valid_destination "$1" ; then
        remove_all_destinations
      fi
      add_destination "$1"
      ;;
    destinationinfo)
      while getopts X opt_name ; do
        case "${opt_name}" in
          X)
            echo "The '-${opt_name}' option for '${verb}' verb is not supported at this time."
            usage
            exit 1
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND - 1 ))
      print_destinations
      ;;
    removedestination)
      remove_destination "$1"
      ;;
    machinedirectory)
      machine_directory
      ;;
    listbackups)
      machine_backups
      ;;
    addexclusion)
      addexclusion_fixed=false
      while getopts p opt_name ; do
        case "$opt_name" in
          p)
            addexclusion_fixed=true
            ;;
          ?)
            usage
            exit 1
            ;;
        esac
      done
      shift $(( $OPTIND -1 ))

      if ! $addexclusion_fixed ; then
        echo "Error! The '-p' option is required for the '${verb}' verb."
        exit 1
      fi
      add_exclusion "$1"
      ;;
  esac
}

main "$@"
